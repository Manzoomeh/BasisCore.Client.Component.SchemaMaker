// Generated by dts-bundle-generator v6.13.0

import { DependencyContainer } from 'tsyringe';

declare enum FaceRowType {
	NotSet = 0,
	Odd = 1,
	Even = 2
}
export declare enum MergeType {
	replace = 0,
	append = 1
}
declare enum Priority {
	high = 0,
	normal = 1,
	low = 2,
	none = 3
}
export interface ISourceOptions {
	mergeType?: MergeType;
	keyFieldName?: string;
	statusFieldName?: string;
	extra?: any;
}
export interface ISource {
	mergeType: MergeType;
	id: SourceId;
	rows: Array<any>;
	keyFieldName?: string;
	statusFieldName?: string;
	versions: Array<number>;
	extra?: any;
	cloneOptions(): ISourceOptions;
	removeRowFormIndex(index: number): void;
	replaceRowFromIndex(index: number, newRow: any): void;
	addRow(row: any): void;
	addRows(rows: any[]): void;
	getVersion(row: any): number;
	replace(source: ISource): void;
}
export type EventHandler<T> = {
	(args?: T): void;
};
export declare type SourceId = string;
export declare type SourceHandler = EventHandler<ISource>;
export declare type HttpMethod = "POST" | "GET";
export declare type SourceData = Array<any> | ISourceData;
export interface ISourceData {
	options: ISourceOptions;
	data: Array<any>;
}
declare class Data {
	readonly rows: Array<any>;
	readonly id: SourceId;
	readonly options?: ISourceOptions;
	constructor(id: SourceId, data: any, options?: ISourceOptions);
}
export type EventHandlerWithReturn<TArgument, TReturn> = {
	(args?: TArgument): TReturn;
};
export interface IDictionary<TValue> {
	[Key: string]: TValue;
}
export interface ILogger {
	logSource(source: ISource): void;
	logError(message: string, exception: Error): void;
	logInformation(message?: any, ...optionalParams: any[]): void;
	logWarning(message: string): void;
}
export interface IPushOptions {
	applicationServerKey: string;
	url: string;
	params: IDictionary<string>;
	permissionDlg: string | {
		(show: boolean): void;
	};
	permissionSubmit: string;
}
export interface IHostOptions {
	debug?: boolean;
	autoRender?: boolean;
	serviceWorker?: boolean | string;
	settings?: IDictionary<any>;
	sources?: IDictionary<SourceData>;
	dbLibPath?: string;
	repositories?: IDictionary<string>;
	push?: IPushOptions;
}
export interface IContextHostOptions extends IHostOptions {
	getDefault<T>(key: string, defaultValue?: T): T;
	getSetting<T>(key: string, defaultValue: T): T;
	originalOptions: Partial<IHostOptions>;
}
export interface IContext {
	logger: ILogger;
	options: IContextHostOptions;
	checkSourceHeartbeatAsync(sourceId: SourceId): Promise<boolean>;
	loadPageAsync(pageName: string, parameters: IDictionary<string>, method?: HttpMethod, url?: string): Promise<string>;
	loadDataAsync(sourceId: SourceId, connectionName: string, parameters: IDictionary<string>, onDataReceived: EventHandlerWithReturn<Array<Data>, boolean>): Promise<void>;
	getOrLoadDbLibAsync(): Promise<any>;
	setAsSource(sourceId: SourceId, data: any, options?: ISourceOptions, preview?: boolean): void;
	setSource(source: ISource, preview?: boolean): void;
	addOnSourceSetHandler(sourceId: SourceId, handler: SourceHandler): void;
	removeOnSourceSetHandler(sourceId: SourceId, handler: SourceHandler): void;
	tryToGetSource(sourceId: SourceId): ISource;
	waitToGetSourceAsync(sourceId: SourceId): Promise<ISource>;
}
export interface IToken<T> {
	context: IContext;
	getValueAsync(wait?: boolean): Promise<T>;
	getSourceNames(): Array<string>;
	getDefault(): T;
}
export declare class HostOptions implements IContextHostOptions {
	debug: boolean;
	autoRender: boolean;
	serviceWorker: boolean | string;
	settings: IDictionary<any>;
	sources: IDictionary<SourceData>;
	dbLibPath: string;
	originalOptions: Partial<IHostOptions>;
	repositories: IDictionary<string>;
	push?: IPushOptions;
	private static _defaultSettings;
	static get defaultSettings(): Partial<IHostOptions>;
	constructor(options: Partial<IHostOptions>);
	getDefault<T>(key: string, defaultValue?: T): T;
	getSetting<T>(key: string, defaultValue: T): T;
}
export interface IDatabase {
	executeAsync<T>(sql: string, params?: any): Promise<T>;
	executeAsTableAsync(sql: string, params?: any): Promise<any[]>;
	dropAsync(): Promise<boolean>;
}
export declare class LocalDataBase implements IDatabase {
	private readonly _dataBaseName;
	private _db;
	private readonly _getSchemas;
	constructor(databaseName: any, getSchemas: () => Map<string, any>);
	dropAsync(): Promise<boolean>;
	executeAsync<T>(sql: string, params?: any): Promise<T>;
	executeAsTableAsync(sql: string, params?: any): Promise<any[]>;
	private InitializeAsync;
}
export interface IDisposable {
	disposeAsync(): Promise<void>;
	disposed: boolean;
}
export interface IComponent extends IDisposable {
	priority: Priority;
	readonly busy: boolean;
	initializeAsync(): Promise<void>;
	processAsync(): Promise<void>;
}
declare class RangeObject {
	private readonly _startNode;
	private readonly _endNode;
	readonly initialContent: DocumentFragment;
	constructor(range: Range, owner: IComponent);
	private getRange;
	deleteContents(): void;
	setContent(content: any | Node, append?: boolean): void;
}
export declare type CallbackArgument = {
	context: IContext;
	node: Node;
};
export declare type RenderingCallbackArgument = CallbackArgument & {
	prevent: boolean;
	source?: ISource;
};
export declare type RenderedCallbackArgument = CallbackArgument & {
	source?: ISource;
	result?: any;
};
declare abstract class Component<TNode extends Node> implements IComponent {
	private readonly _handler;
	private readonly _handlingSource;
	readonly node: TNode;
	readonly context: IContext;
	readonly priority: Priority;
	protected allowMultiProcess: boolean;
	private _busy;
	get disposed(): boolean;
	private _disposed;
	get busy(): boolean;
	constructor(node: TNode, context: IContext);
	processAsync(): Promise<void>;
	protected onTrigger(source?: ISource): Promise<void>;
	addTrigger(sourceIds: Array<SourceId>): void;
	disposeAsync(): Promise<void>;
	abstract initializeAsync(): Promise<void>;
	abstract renderAsync(source?: ISource): Promise<void>;
}
declare abstract class ElementBaseComponent<TElement extends Element> extends Component<TElement> {
	protected onRenderingAsync: (args: RenderingCallbackArgument) => Promise<void>;
	protected onRenderedAsync: (args: RenderedCallbackArgument) => Promise<void>;
	protected onProcessingAsync: (args: CallbackArgument) => Promise<void>;
	protected onProcessedAsync: (args: CallbackArgument) => Promise<void>;
	protected ifToken: IToken<string>;
	protected isHide: boolean;
	private _triggers;
	get triggers(): string[];
	constructor(element: TElement, context: IContext);
	initializeAsync(): Promise<void>;
	protected getIfValueAsync(): Promise<boolean>;
	renderAsync(source?: ISource): Promise<void>;
	getAttributeValueAsync(attributeName: string, defaultValue?: string): Promise<string>;
	getAttributeObjectValueAsync(attributeName: string, defaultValue?: any): Promise<any>;
	getAttributeBooleanValueAsync(attributeName: string, defaultValue?: boolean): Promise<Boolean>;
	getAttributeToken(attributeName: string): IToken<string>;
	protected createCallbackArgument<T extends CallbackArgument>(data?: Partial<T>): T;
	protected abstract runAsync(source?: ISource): Promise<any>;
	protected hideAsync(): Promise<void>;
}
declare abstract class CommandComponent extends ElementBaseComponent<Element> {
	readonly core: string;
	readonly range: RangeObject;
	readonly content: DocumentFragment;
	constructor(element: Element, context: IContext);
	protected setContent(newContent: Node, append: boolean): void;
}
export interface IBCWrapper {
	elementList: Array<Element>;
	addFragment(selector: string): IBCWrapper;
	addFragment(element: Element): IBCWrapper;
	addFragment(param: any): IBCWrapper;
	setOptions(options: IHostOptions): IBCWrapper;
	run(): IBCWrapper;
	setSource(sourceId: SourceId, data: any, options?: ISourceOptions): IBCWrapper;
	GetCommandListByCore(core: string): Array<CommandComponent>;
	GetCommandList(): Array<CommandComponent>;
	GetComponentList(): Array<IComponent>;
}
export interface IBCWrapperFactory {
	all: Array<IBCWrapper>;
	global: IBCWrapper;
	elementList: Array<Element>;
	addFragment(selector: string): IBCWrapper;
	addFragment(element: Element): IBCWrapper;
	addFragment(param: any): IBCWrapper;
	setOptions(options: IHostOptions): IBCWrapper;
	run(): IBCWrapper;
	setSource(sourceId: SourceId, data: any, options?: ISourceOptions): IBCWrapper;
}
export interface ISourceWrapper {
	sortAsync(source: ISource, sort: string, context: IContext): Promise<ISource>;
	filterAsync(source: ISource, filter: string, context: IContext): Promise<any[]>;
	isNullOrEmpty(data: string): boolean;
	runSqlAsync(source: ISource, sql: string, context: IContext): Promise<ISource>;
	data(id: SourceId, data: any, options?: ISourceOptions): Data;
}
export interface IUtilWrapper {
	cloneDeep<T>(obj: T): T;
	defaultsDeep<T>(data: Partial<T>, defaults: Partial<T>): T;
	getLibAsync(objectName: string, url: string): Promise<any>;
	toNode(rawXML: string): DocumentFragment;
	toHTMLElement(rawXml: string): HTMLElement;
	toElement(rawXML: string): Element;
	getComponentAsync(context: IContext, key: string): Promise<any>;
	storeAsGlobal(data: any, name?: string, prefix?: string, postfix?: string): string;
	getRandomName(prefix?: string, postfix?: string): string;
	format(pattern: string, ...params: any[]): string;
	addMessageHandler(messageType: string, handler: EventHandler<any>): boolean;
	source: ISourceWrapper;
}
export interface IBCUtil {
	util: IUtilWrapper;
}
export declare class BCWrapperFactory implements IBCWrapperFactory, IBCUtil {
	elementList: Element[];
	private _global;
	readonly all: Array<IBCWrapper>;
	get global(): IBCWrapper;
	readonly util: IUtilWrapper;
	addFragment(selector: string): IBCWrapper;
	addFragment(element: Element): IBCWrapper;
	setOptions(options: IHostOptions): IBCWrapper;
	run(): IBCWrapper;
	setSource(sourceId: SourceId, data: any, options?: ISourceOptions): IBCWrapper;
	new(): IBCWrapper;
}
export interface IComponentCollection extends IDisposable {
	GetCommandListByCore(core: string): Array<CommandComponent>;
	GetCommandList(): Array<CommandComponent>;
	GetComponentList(): Array<IComponent>;
}
export interface IComponentManager {
	initializeAsync(): Promise<void>;
	runAsync(source?: ISource): Promise<any>;
}
export interface IUserDefineComponent {
	content: DocumentFragment;
	range: RangeObject;
	triggers: string[];
	priority: Priority;
	dc: DependencyContainer;
	toNode(rawHtml: string): DocumentFragment;
	toHTMLElement(rawXml: string): HTMLElement;
	setContent(newContent: Node): void;
	getAttributeValueAsync(name: string, defaultValue?: string): Promise<string>;
	getAttributeBooleanValueAsync(name: string, defaultValue?: boolean): Promise<Boolean>;
	getAttributeToken(attributeName: string): IToken<string>;
	addTrigger(sourceIds: Array<SourceId>): any;
	setSource(sourceId: SourceId, data: any, options?: ISourceOptions, preview?: boolean): void;
	tryToGetSource(sourceId: SourceId): ISource;
	waitToGetSourceAsync(sourceId: SourceId): Promise<ISource>;
	getDefault<T>(key: string, defaultValue?: T): T;
	getSetting<T>(key: string, defaultValue: T): T;
	processNodesAsync(nodes: Array<Node>): Promise<IComponentCollection>;
	disposeAsync(): Promise<void>;
	disposed: boolean;
	storeAsGlobal(data: any, name?: string, prefix?: string, postfix?: string): string;
	getRandomName(prefix?: string, postfix?: string): string;
	format(pattern: string, ...params: any[]): string;
	getLibAsync(objectName: string, url: string): Promise<any>;
	manager: IComponentManager;
	onInitialized: Promise<IUserDefineComponent>;
	node: Element;
}
declare class ExposerComponent {
	private readonly owner;
	constructor(owner: IUserDefineComponent);
	initializeAsync(): Promise<void>;
	runAsync(source?: ISourceOptions): Promise<void>;
}
declare abstract class ConnectionOptions {
	readonly Name: string;
	constructor(name: string);
	abstract TestConnectionAsync(context: IContext): Promise<boolean>;
	abstract loadDataAsync(context: IContext, sourceId: SourceId, parameters: IDictionary<string>, onDataReceived: EventHandlerWithReturn<Array<Data>, boolean>): Promise<void>;
	abstract loadPageAsync(context: IContext, pageName: string, parameters: IDictionary<string>, method?: HttpMethod): Promise<string>;
	ParseJsonString(json: string): ParsedData;
	ConvertObject(obj: IDictionary<any[]>): ParsedData;
}
declare class ParsedData {
	Setting: any;
	Tables: Array<Pair<string, any[]>>;
}
declare class Pair<K, V> {
	readonly Key: K;
	readonly Value: V;
	constructor(Key: K, Value: V);
}
declare class ConnectionOptionsManager {
	private readonly connections;
	constructor(hostSettings: IDictionary<any>, context: IContext);
	getConnection(connectionName: string): ConnectionOptions;
}
export interface IEvent<T> {
	Add(handler: EventHandler<T>): EventHandler<T>;
	Remove(handler: EventHandler<T>): EventHandler<T>;
}
export interface IEventManager<T> {
	Trigger(data?: T): void;
}
export declare class EventManager<T> implements IEvent<T>, IEventManager<T> {
	private readonly handlers;
	Add(handler: EventHandler<T>): EventHandler<T>;
	Remove(handler: EventHandler<T>): EventHandler<T>;
	Trigger(args?: T): void;
}
export interface IRepository {
	setSource(source: ISource, preview?: boolean): ISource;
	addHandler(sourceId: SourceId, handler: SourceHandler): void;
	removeHandler(sourceId: SourceId, handler: SourceHandler): void;
	tryToGet(sourceId: SourceId): ISource;
	waitToGetAsync(sourceId: SourceId): Promise<ISource>;
}
export interface IContextRepository extends IRepository {
	resolves: Map<string, EventManager<ISource>>;
	setSourceFromOwner(source: ISource): void;
}
declare abstract class Context implements IContext {
	protected readonly repository: IContextRepository;
	readonly logger: ILogger;
	readonly options: IContextHostOptions;
	readonly onDataSourceSet: EventManager<ISource>;
	constructor(repository: IContextRepository, options: IContextHostOptions, logger: ILogger);
	abstract getOrLoadDbLibAsync(): Promise<any>;
	abstract loadDataAsync(sourceId: SourceId, connectionName: string, parameters: IDictionary<string>, onDataReceived: EventHandlerWithReturn<Array<Data>, boolean>): Promise<void>;
	abstract loadPageAsync(pageName: string, parameters: IDictionary<string>, method?: HttpMethod, url?: string): Promise<string>;
	checkSourceHeartbeatAsync(source: string): Promise<boolean>;
	private onDataSourceSetHandler;
	addOnSourceSetHandler(sourceId: SourceId, handler: SourceHandler): void;
	removeOnSourceSetHandler(sourceId: SourceId, handler: SourceHandler): void;
	tryToGetSource(sourceId: SourceId): ISource;
	waitToGetSourceAsync(sourceId: SourceId): Promise<ISource>;
	setAsSource(sourceId: SourceId, data: any, options?: ISourceOptions, preview?: boolean): void;
	setSource(source: ISource, preview?: boolean): void;
	setSourceFromOwner(source: ISource): void;
	dispose(): void;
}
declare abstract class RootContext extends Context {
	readonly connections: ConnectionOptionsManager;
	readonly loadLibDic: IDictionary<Promise<any>>;
	constructor(repository: IContextRepository, options: HostOptions, logger: ILogger);
	loadPageAsync(pageName: string, parameters: IDictionary<string>, method?: HttpMethod, url?: string): Promise<string>;
	loadDataAsync(sourceId: SourceId, connectionName: string, parameters: IDictionary<string>, onDataReceived: EventHandlerWithReturn<Array<Data>, boolean>): Promise<void>;
	getOrLoadDbLibAsync(): Promise<any>;
	private addHostOptionsSource;
}
export interface IBasisCore {
	context: RootContext;
	setSource(sourceId: SourceId, data: any, options?: ISourceOptions): any;
	GetCommandListByCore(core: string): Array<CommandComponent>;
	GetCommandList(): Array<CommandComponent>;
	GetComponentList(): Array<IComponent>;
}
declare class ComponentCollection implements IComponentCollection {
	static readonly knowHtmlElement: string[];
	readonly context: IContext;
	readonly regex: RegExp;
	readonly blockRegex: RegExp;
	readonly container: DependencyContainer;
	private _initializeTask;
	private components;
	private _disposed;
	get disposed(): boolean;
	get initializeTask(): Promise<void>;
	constructor(context: IContext, container: DependencyContainer);
	processNodesAsync(nodes: Array<Node>): Promise<void>;
	private initializeAsync;
	private runAsync;
	private extractComponent;
	private extractBasisCommands;
	private extractTextComponent;
	private extractAttributeComponent;
	private extractTextBaseComponents;
	private createCommandComponent;
	private findRootLevelComponentNode;
	disposeAsync(): Promise<void>;
	GetCommandListByCore(core: string): Array<CommandComponent>;
	GetCommandList(): Array<CommandComponent>;
	GetComponentList(): Array<IComponent>;
}
declare class BasisCoreRootContext extends RootContext {
	constructor(repository: IContextRepository, logger: ILogger, container: DependencyContainer, options: HostOptions);
	addQueryString(queryString: string): void;
	private addRequestRelatedSources;
}
export declare class BasisCore implements IBasisCore {
	readonly context: BasisCoreRootContext;
	readonly content: ComponentCollection;
	constructor(context: BasisCoreRootContext, container: DependencyContainer, nodes: Array<Node>);
	GetCommandListByCore(core: string): CommandComponent[];
	GetCommandList(): CommandComponent[];
	GetComponentList(): IComponent[];
	setSource(sourceId: SourceId, data: any, options?: ISourceOptions): void;
}
export declare class CallComponent extends CommandComponent {
	private defaultAttributeNames;
	private readonly container;
	readonly priority: Priority;
	private collection;
	private urlToken;
	private fileToken;
	private pageSizeToken;
	private methodeToken;
	private contentToken;
	constructor(element: Element, context: IContext, container: DependencyContainer);
	initializeAsync(): Promise<void>;
	protected runAsync(): Promise<void>;
	disposeAsync(): Promise<void>;
}
export declare class GroupComponent extends CommandComponent {
	private _collections;
	readonly container: DependencyContainer;
	readonly childNodes: Array<ChildNode>;
	private oldLocalContext;
	private currentDC;
	constructor(element: Element, context: IContext, container: DependencyContainer);
	private fillContent;
	runAsync(): Promise<void>;
	protected hideAsync(): Promise<void>;
	processNodesAsync(nodes: Array<Node>): Promise<IComponentCollection>;
	disposeAsync(): Promise<void>;
}
declare abstract class SourceBaseComponent extends CommandComponent {
	protected sourceId: SourceId;
	constructor(element: Element, context: IContext);
	processAsync(): Promise<void>;
	runAsync(source?: ISource): Promise<any>;
	protected abstract renderSourceAsync(dataSource: ISource): Promise<any>;
}
export interface ILocalContext extends IContext {
	dispose(): void;
}
export declare class RepeaterComponent extends SourceBaseComponent {
	readonly container: DependencyContainer;
	readonly oldChildContexts: Array<ILocalContext>;
	readonly collections: Array<ComponentCollection>;
	constructor(element: Element, context: IContext, container: DependencyContainer);
	protected renderSourceAsync(dataSource: ISource): Promise<void>;
	private disposeExistingObjectAsync;
	disposeAsync(): Promise<void>;
}
declare abstract class HTMLComponent<TElement extends HTMLElement> extends ElementBaseComponent<TElement> {
	protected eventTriggers: Array<string>;
	readonly priority: Priority;
	readonly keyFieldNameToken: IToken<string>;
	readonly statusFieldNameToken: IToken<string>;
	readonly mergeTypeToken: IToken<string>;
	readonly eventHandler: EventListenerOrEventListenerObject;
	readonly isCheckBox: boolean;
	constructor(element: TElement, context: IContext);
	initializeAsync(): Promise<void>;
	protected runAsync(source?: ISource): Promise<void>;
	protected onEventTriggerAsync(event?: Event): Promise<void>;
	protected getSourceIdAsync(): Promise<SourceId>;
	protected getSourceValueAsync(event: Event): Promise<any>;
	disposeAsync(): Promise<void>;
}
export declare class HTMLFormComponent extends HTMLComponent<HTMLFormElement> {
	constructor(element: HTMLFormElement, context: IContext);
	protected getSourceValueAsync(event: Event): Promise<any>;
	private convertRootList;
}
export declare class HTMLInputComponent extends HTMLComponent<HTMLInputElement> {
	constructor(element: HTMLInputElement, context: IContext);
	protected getSourceValueAsync(event: Event): Promise<any>;
}
export declare class HTMLIUnknownComponent extends HTMLComponent<HTMLElement> {
	constructor(element: HTMLElement, context: IContext);
}
export declare class HTMLSelectComponent extends HTMLComponent<HTMLSelectElement> {
	constructor(element: HTMLSelectElement, context: IContext);
	protected getSourceValueAsync(event: Event): Promise<any>;
}
export declare class CookieComponent extends CommandComponent {
	constructor(element: Element, context: IContext);
	runAsync(): Promise<void>;
}
declare class FaceRenderResult {
	readonly key: any;
	readonly version: number;
	readonly nodes: Array<Node>;
	constructor(key: any, version: number, element: Element);
	AppendTo(newParent: Node | Range): void;
}
export interface ITemplate<TResult> {
	getValueAsync(data: any): Promise<TResult>;
}
declare class Face {
	Name: string;
	RowType: FaceRowType;
	RelatedRows: Array<any[]>;
	template: ITemplate<string>;
	Levels: string[];
}
declare class FaceRenderResultRepository<T extends FaceRenderResult> {
	private readonly groups;
	set(key: any, value: T, groupName?: string): void;
	get(key: any, groupName?: string): T | undefined;
}
declare class RenderParam<TRenderResult extends FaceRenderResult> {
	Levels: string[];
	_renderedCount: number;
	readonly groupName?: string;
	readonly source: ISource;
	readonly factory: RenderResultFactory;
	readonly renderResultRepository: FaceRenderResultRepository<TRenderResult>;
	get rowType(): FaceRowType;
	constructor(source: ISource, renderResultRepository: FaceRenderResultRepository<TRenderResult>, renderResultFactory: RenderResultFactory, groupName?: string);
	getRenderedResultAsync(data: any): Promise<[
		any,
		number,
		TRenderResult
	]>;
	getKeyValue(data: any): any;
	setLevel(levels: string[]): void;
	setRendered(): void;
	setIgnored(): void;
}
export declare type RenderResultFactory = (key: any, version: number, node: Element) => any;
declare class FaceCollection extends Array<Face> {
	constructor(...faces: Face[]);
	renderAsync<TRenderResult extends FaceRenderResult>(param: RenderParam<TRenderResult>, data: object): Promise<TRenderResult>;
}
declare class RenderDataPartResult<TRenderResult extends FaceRenderResult> {
	readonly result: Array<TRenderResult>;
	readonly repository: FaceRenderResultRepository<TRenderResult>;
	constructor(result: Array<TRenderResult>, repository: FaceRenderResultRepository<TRenderResult>);
}
declare abstract class RenderableComponent<TRenderResult extends FaceRenderResult> extends SourceBaseComponent {
	private _preCollection;
	readonly container: DependencyContainer;
	readonly reservedKeys: Array<string>;
	protected renderResultRepository: FaceRenderResultRepository<TRenderResult>;
	constructor(element: Element, context: IContext, container: DependencyContainer, reservedKeys?: Array<string>);
	renderSourceAsync(source: ISource): Promise<Node[]>;
	protected createContentAsync(renderResult?: Array<TRenderResult>): Promise<ChildNode[]>;
	protected renderDataPartAsync(dataSource: ISource, faces: FaceCollection): Promise<RenderDataPartResult<TRenderResult>>;
	protected appendTemplateToDoc(template: string, doc: DocumentFragment): void;
	protected setContentAsync(doc: DocumentFragment): Promise<Array<ChildNode>>;
}
export declare class ListComponent extends RenderableComponent<FaceRenderResult> {
	constructor(element: Element, context: IContext, container: DependencyContainer);
	protected createContentAsync(renderResults?: Array<FaceRenderResult>): Promise<ChildNode[]>;
}
export declare class PrintComponent extends RenderableComponent<FaceRenderResult> {
	constructor(element: Element, context: IContext, container: DependencyContainer);
}
export interface ISchema {
	paramUrl: string;
	schemaId: string;
	schemaVersion: string;
	lid: number;
}
export interface IQuestionSchema extends ISchema {
	schemaName: string;
	baseVocab: string;
	questions: Array<IQuestion>;
	sections: Array<ISection>;
}
export interface IQuestion {
	prpId: number;
	typeId: number;
	ord: number;
	vocab: string;
	title: string;
	wordId: number;
	multi: boolean;
	sectionId: number;
	cssClass: string;
	help?: string;
	disabled?: boolean;
	useInList?: boolean;
	parts: Array<IQuestionPart>;
}
export interface IQuestionPart {
	part: number;
	viewType: string | ViewType;
	cssClass: string;
	validations: IValidationOptions;
	caption?: string;
	link?: string;
	uploadToken?: string;
	fixValues?: Array<IFixValue>;
	dependency?: Array<IDependency>;
	method?: WebMethod;
	disabled?: boolean;
	readonly?: boolean;
	options?: any;
	multiple?: boolean;
	formIdContent?: string;
}
export type WebMethod = "POST" | "GET";
export type ViewType = "Text" | "Textarea" | "Autocomplete" | "Reference" | "Select" | "Upload" | "Datepicker" | "Checklist" | "Popup" | "Radio" | "Lookup" | "Time" | "Color" | "Blob";
export interface ISection {
	id: number;
	title: string;
	description: string;
}
export type AnswerDataType = "float" | "int";
export interface IValidationOptions {
	minLength?: number;
	maxLength?: number;
	min?: number;
	max?: number;
	dataType?: AnswerDataType;
	required?: boolean;
	regex?: string;
	mimes?: Array<IMimes>;
	size?: number;
}
export interface IFixValue {
	id: number;
	value: string;
	selected?: boolean;
	schema?: ISchema;
}
export interface IDependency {
	prpId: number;
	part: number;
	name: string;
	required: boolean;
}
export interface IMimes {
	mime: string;
	minSize: number;
	maxSize: number;
}
export interface IUserActionResult extends ISchema {
	usedForId?: number;
	ownerid?: number;
	properties: Array<IUserActionProperty>;
}
export interface IUserActionProperty {
	propId: number;
	multi: boolean;
	added?: Array<IUserActionAnswer>;
	edited?: Array<IUserActionAnswer>;
	deleted?: Array<IUserActionAnswer>;
}
export interface IUserActionAnswer {
	id?: number;
	parts?: Array<IUserActionPart>;
}
export interface IUserActionPart {
	part: number;
	values: Array<IUserActionPartValue>;
}
export interface IUserActionPartValue {
	id?: number;
	value?: any;
	answer?: IUserActionResult;
}
export interface IAnswerSchema extends ISchema {
	usedForId: number;
	ownerid?: number;
	lastUpdate: string;
	properties: Array<IAnswerProperty>;
}
export interface IAnswerProperty {
	prpId: number;
	answers: Array<IAnswerPart>;
}
export interface IAnswerPart {
	id?: number;
	parts: Array<IPartCollection>;
}
export interface IPartCollection {
	part: number;
	values: Array<IPartValue>;
}
export interface IPartValue {
	id?: number;
	value: any;
	answer?: IAnswerSchema;
}
export declare class SchemaComponent extends SourceBaseComponent {
	private _questions;
	private readonly _dc;
	private schemaUrlToken;
	private paramUrlToken;
	private displayModeToken;
	private buttonSelector;
	private resultSourceIdToken;
	private errorResultSourceIdToken;
	private callbackToken;
	private schemaCallbackToken;
	private cellToken;
	private filesPathToken;
	private _currentCellManager;
	private getAnswersAndSetAsSource;
	private _schema;
	private _answer;
	constructor(element: Element, context: IContext, container: DependencyContainer);
	initializeAsync(): Promise<void>;
	private onClick;
	runAsync(source?: ISource): Promise<any>;
	protected renderSourceAsync(dataSource: ISource): Promise<any>;
	initUIAsync(answer?: IAnswerSchema): Promise<void>;
	getAnswersAsync(throwError: boolean): Promise<IUserActionResult>;
}
declare class TreeFaceRenderResult extends FaceRenderResult {
	private contentRange;
	private contentNodes;
	constructor(key: any, version: number, element: Element);
	setContent(content: DocumentFragment): void;
}
export declare class TreeComponent extends RenderableComponent<TreeFaceRenderResult> {
	constructor(element: Element, context: IContext, container: DependencyContainer);
	protected FaceRenderResultFactory(key: any, version: number, doc: HTMLElement): TreeFaceRenderResult;
	protected renderDataPartAsync(dataSource: ISource, faces: FaceCollection): Promise<RenderDataPartResult<TreeFaceRenderResult>>;
	private renderLevelAsync;
}
export declare class ViewComponent extends RenderableComponent<TreeFaceRenderResult> {
	constructor(element: Element, context: IContext, container: DependencyContainer);
	protected renderDataPartAsync(dataSource: ISource, faces: FaceCollection): Promise<RenderDataPartResult<TreeFaceRenderResult>>;
}
declare abstract class SourceComponent extends CommandComponent {
	readonly priority: Priority;
	constructor(element: Element, context: IContext);
}
export declare class APIComponent extends SourceComponent {
	readonly urlToken: IToken<string>;
	readonly methodToken: IToken<string>;
	readonly bodyToken: IToken<string>;
	readonly nameToken: IToken<string>;
	readonly contentType: IToken<string>;
	readonly noCacheToken: IToken<string>;
	constructor(element: Element, context: IContext);
	protected runAsync(): Promise<void>;
}
export declare class CallbackComponent extends CommandComponent {
	readonly methodToken: IToken<string>;
	readonly priority: Priority;
	constructor(element: Element, context: IContext);
	protected runAsync(source?: ISource): Promise<any>;
}
declare abstract class Member {
	readonly name: string;
	readonly previewToken: IToken<boolean>;
	readonly sortToken: IToken<string>;
	readonly postSqlToken: IToken<string>;
	readonly extraAttributes: IDictionary<IToken<string>>;
	readonly rawContentToken: IToken<string>;
	readonly element: Element;
	readonly context: IContext;
	constructor(element: Element, context: IContext);
	addDataSourceAsync(data: Array<any>, sourceId: SourceId, options?: ISourceOptions): Promise<void>;
}
declare class DbSourceMember extends Member {
	constructor(element: Element, context: IContext);
}
declare abstract class MemberBaseSourceComponent<T extends Member> extends SourceComponent {
	protected id: SourceId;
	private connection;
	readonly members: Array<Element>;
	abstract convertToMemberObject(element: Element): T;
	constructor(element: Element, context: IContext);
	initializeAsync(): Promise<void>;
	protected runAsync(): Promise<void>;
	private processLoadedDataSet;
	private loadDataAsync;
}
export declare class DbSourceComponent extends MemberBaseSourceComponent<DbSourceMember> {
	constructor(element: Element, context: IContext);
	convertToMemberObject(element: Element): DbSourceMember;
}
declare abstract class ComponentContainer extends CommandComponent {
	readonly dc: DependencyContainer;
	constructor(element: Element, context: IContext, container: DependencyContainer);
	toNode(rawHtml: string): DocumentFragment;
	toHTMLElement(rawXml: string): HTMLElement;
	toElement(rawXml: string): Element;
	getDefault<T>(key: string, defaultValue?: T): T;
	getSetting<T>(key: string, defaultValue: T): T;
	setSource(sourceId: SourceId, data: any, options?: ISourceOptions, preview?: boolean): void;
	tryToGetSource(sourceId: SourceId): ISource;
	waitToGetSourceAsync(sourceId: SourceId): Promise<ISource>;
	storeAsGlobal(data: any, name?: string, prefix?: string, postfix?: string): string;
	getRandomName(prefix?: string, postfix?: string): string;
	format(pattern: string, ...params: any[]): string;
}
export declare class UserDefineComponent extends ComponentContainer implements IUserDefineComponent {
	private collections;
	manager: IComponentManager;
	readonly onInitialized: Promise<IUserDefineComponent>;
	private _resolve;
	private _reject;
	constructor(element: Element, context: IContext, container: DependencyContainer);
	getLibAsync(objectName: string, url: string): Promise<any>;
	initializeAsync(): Promise<void>;
	protected runAsync(source?: ISource): Promise<any>;
	setContent(newContent: Node): void;
	processNodesAsync(nodes: Array<Node>): Promise<IComponentCollection>;
	disposeAsync(): Promise<void>;
}
export declare class LocalContext extends Context implements ILocalContext {
	readonly owner: Context;
	readonly handler: SourceHandler;
	constructor(repository: IContextRepository, owner: Context, options: HostOptions);
	dispose(): void;
	getOrLoadDbLibAsync(): Promise<any>;
	getOrLoadObjectAsync(object: string, url: string): Promise<any>;
	loadPageAsync(pageName: string, parameters: IDictionary<string>, method?: HttpMethod, url?: string): Promise<string>;
	loadDataAsync(sourceId: SourceId, connectionName: string, parameters: IDictionary<string>, onDataReceived: EventHandlerWithReturn<Array<Data>, boolean>): Promise<void>;
	tryToGetSource(sourceId: SourceId): ISource;
}
export interface IDependencyContainer {
	register<T>(token: InjectionToken<T>, provider: ValueProvider<T>): IDependencyContainer;
	register<T>(token: InjectionToken<T>, provider: FactoryProvider<T>): IDependencyContainer;
	register<T>(token: InjectionToken<T>, provider: TokenProvider<T>, options?: RegistrationOptions): IDependencyContainer;
	register<T>(token: InjectionToken<T>, provider: ClassProvider<T>, options?: RegistrationOptions): IDependencyContainer;
	register<T>(token: InjectionToken<T>, provider: constructor<T>, options?: RegistrationOptions): IDependencyContainer;
	registerSingleton<T>(from: InjectionToken<T>, to: InjectionToken<T>): IDependencyContainer;
	registerSingleton<T>(token: constructor<T>): IDependencyContainer;
	registerType<T>(from: InjectionToken<T>, to: InjectionToken<T>): IDependencyContainer;
	registerInstance<T>(token: InjectionToken<T>, instance: T): IDependencyContainer;
	/**
	 * Resolve a token into an instance
	 *
	 * @param token The dependency token
	 * @return An instance of the dependency
	 */
	resolve<T>(token: InjectionToken<T>): T;
	resolveAll<T>(token: InjectionToken<T>): T[];
	/**
	 * Check if the given dependency is registered
	 *
	 * @param token The token to check
	 * @param recursive Should parent containers be checked?
	 * @return Whether or not the token is registered
	 */
	isRegistered<T>(token: InjectionToken<T>, recursive?: boolean): boolean;
	/**
	 * Clears all registered tokens
	 */
	reset(): void;
	clearInstances(): void;
	createChildContainer(): IDependencyContainer;
}
export declare type InjectionToken<T = any> = constructor<T> | string | symbol;
export interface ValueProvider<T> {
	useValue: T;
}
export interface FactoryProvider<T> {
	useFactory: (dependencyContainer: IDependencyContainer) => T;
}
export interface TokenProvider<T> {
	useToken: string;
}
export declare type constructor<T> = {
	new (...args: any[]): T;
};
export interface ClassProvider<T> {
	useClass: constructor<T> | DelayedConstructor<T>;
}
declare class DelayedConstructor<T> {
	private wrap;
	private reflectMethods;
	constructor(wrap: () => constructor<T>);
	createProxy(createObject: (ctor: constructor<T>) => T): T;
	private createHandler;
}
declare enum Lifecycle {
	Transient = 0,
	Singleton = 1,
	ResolutionScoped = 2,
	ContainerScoped = 3
}
export declare type RegistrationOptions = {
	/**
	 * Customize the lifecycle of the registration
	 * See https://github.com/microsoft/tsyringe#available-scopes for more information
	 */
	lifecycle: Lifecycle;
};
export declare const $bc: BCWrapperFactory;

export {
	ExposerComponent as exposer,
};

export {};
